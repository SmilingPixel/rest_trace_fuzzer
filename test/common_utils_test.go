// Package test contains unit tests for utility functions in the resttracefuzzer project.
// These tests validate the correctness and robustness of various utility functions
// such as random string generation, type conversions, and edge case handling.
//
// Note: This test file was generated by Gemini 2.5 Pro.

package test

import (
	"bytes"
	"encoding/base64"
	"math"
	"reflect"
	"resttracefuzzer/pkg/utils"
	"slices" // Requires Go 1.21+
	"testing"
)

// --- Test RandStringBytes ---

func TestRandStringBytes(t *testing.T) {
	testCases := []struct {
		name   string
		length int
	}{
		{"ZeroLength", 0},
		{"ShortLength", 10},
		{"LongLength", 100},
	}

	const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := utils.RandStringBytes(tc.length)
			if len(result) != tc.length {
				t.Errorf("RandStringBytes(%d) length = %d; want %d", tc.length, len(result), tc.length)
			}
			// Optional: Check if all characters are within the allowed set
			for _, r := range result {
				isAllowed := false
				for _, allowed := range letterBytes {
					if r == allowed {
						isAllowed = true
						break
					}
				}
				if !isAllowed {
					t.Errorf("RandStringBytes(%d) produced character '%c' which is not in allowed set", tc.length, r)
				}
			}
		})
	}
}

// --- Test MutateRandBytes & MutateRandBytesForString ---

func TestMutateRandBytesForString(t *testing.T) {
	originalString := "abcdefghijklmnopqrstuvwxyz0123456789"

	t.Run("NoMutations_MaxZero", func(t *testing.T) {
		mutated := utils.MutateRandBytesForString(originalString, 1.0, 0)
		if mutated != originalString {
			t.Errorf("Expected no mutations when maxMutations is 0, got %q, want %q", mutated, originalString)
		}
	})

	t.Run("NoMutations_ProbZero", func(t *testing.T) {
		mutated := utils.MutateRandBytesForString(originalString, 0.0, 10)
		if mutated != originalString {
			t.Errorf("Expected no mutations when mutationProbability is 0.0, got %q, want %q", mutated, originalString)
		}
	})

	t.Run("InvalidProbability_Negative", func(t *testing.T) {
		mutated := utils.MutateRandBytesForString(originalString, -0.5, 10)
		if mutated != originalString {
			t.Errorf("Expected no mutations for negative probability, got %q, want %q", mutated, originalString)
		}
		// Note: This test doesn't check for the log warning.
	})

	t.Run("InvalidProbability_GreaterThanOne", func(t *testing.T) {
		mutated := utils.MutateRandBytesForString(originalString, 1.5, 10)
		if mutated != originalString {
			t.Errorf("Expected no mutations for probability > 1, got %q, want %q", mutated, originalString)
		}
		// Note: This test doesn't check for the log warning.
	})

	t.Run("PotentialMutation_HighProbability", func(t *testing.T) {
		mutated := utils.MutateRandBytesForString(originalString, 0.9, len(originalString))
		if len(mutated) != len(originalString) {
			t.Errorf("Mutated string length mismatch: got %d, want %d", len(mutated), len(originalString))
		}
		// It's highly probable, but not guaranteed, that the string changed.
		// A stronger test might run this multiple times or check the underlying bytes.
		if mutated == originalString {
			t.Logf("Warning: High probability mutation did not change the string (statistically possible). Original: %q, Mutated: %q", originalString, mutated)
		}
	})
}

// --- Test ConvertIntTo64BitType ---

func TestConvertIntTo64BitType(t *testing.T) {
	testCases := []struct {
		name     string
		input    any
		expected int64
	}{
		{"Int", int(42), int64(42)},
		{"Int8", int8(42), int64(42)},
		{"Int16", int16(42), int64(42)},
		{"Int32", int32(42), int64(42)},
		{"Int64", int64(42), int64(42)},
		{"NegativeInt", int(-100), int64(-100)},
		{"UnsupportedUint", uint(10), int64(0)},
		{"UnsupportedFloat", float32(1.0), int64(0)},
		{"UnsupportedString", "hello", int64(0)},
		{"UnsupportedNil", nil, int64(0)},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := utils.ConvertIntTo64BitType(tc.input)
			if result != tc.expected {
				t.Errorf("ConvertIntTo64BitType(%T(%v)) = %d; want %d", tc.input, tc.input, result, tc.expected)
			}
			// Note: This test doesn't check for the log warning on unsupported types.
		})
	}
}

// --- Test ConvertFloatTo64BitType ---

func TestConvertFloatTo64BitType(t *testing.T) {
	testCases := []struct {
		name     string
		input    any
		expected float64
	}{
		{"Float32", float32(42.5), float64(42.5)},
		{"Float64", float64(42.5), float64(42.5)},
		{"NegativeFloat32", float32(-100.1), float64(float32(-100.1))}, // Be careful with float precision
		{"UnsupportedInt", int(10), float64(0.0)},
		{"UnsupportedString", "hello", float64(0.0)},
		{"UnsupportedNil", nil, float64(0.0)},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := utils.ConvertFloatTo64BitType(tc.input)
			// Direct float comparison can be tricky due to precision. Use a tolerance if necessary.
			if math.Abs(result-tc.expected) > 1e-9 {
				t.Errorf("ConvertFloatTo64BitType(%T(%v)) = %f; want %f", tc.input, tc.input, result, tc.expected)
			}
			// Note: This test doesn't check for the log warning on unsupported types.
		})
	}
}

// --- Test NormInt64 ---

func TestNormInt64(t *testing.T) {
	// Basic test: Ensure it runs without panic and returns an int64
	// A full statistical test is complex for a unit test.
	mean := int64(1000)
	stdDev := int64(50)

	// Run a few times to catch immediate issues
	for i := 0; i < 10; i++ {
		val := utils.NormInt64(mean, stdDev)
		// We expect values to be *around* the mean. This is a loose check.
		if val < mean-5*stdDev || val > mean+5*stdDev {
			t.Logf("NormInt64(%d, %d) produced value %d which is > 5 stdDevs from mean (might be statistically rare or an issue)", mean, stdDev, val)
		}
		// Check type
		if _, ok := interface{}(val).(int64); !ok {
			t.Errorf("NormInt64(%d, %d) returned type %T, want int64", mean, stdDev, val)
		}
	}
}

// --- Test DefaultValueForPrimitiveTypeKind ---

func TestDefaultValueForPrimitiveTypeKind(t *testing.T) {
	testCases := []struct {
		name          string
		kind          reflect.Kind
		expectedValue any
		expectedType  reflect.Type
	}{
		{"Int64", reflect.Int64, int64(114514), reflect.TypeOf(int64(0))},
		{"Float64", reflect.Float64, 114.514, reflect.TypeOf(float64(0.0))},
		{"Bool", reflect.Bool, true, reflect.TypeOf(true)},
		{"String", reflect.String, "114-514", reflect.TypeOf("")},
		{"UnsupportedMap", reflect.Map, nil, nil}, // Expect nil for unsupported
		{"UnsupportedStruct", reflect.Struct, nil, nil},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := utils.DefaultValueForPrimitiveTypeKind(tc.kind)
			if result != tc.expectedValue {
				t.Errorf("DefaultValueForPrimitiveTypeKind(%v) value = %v (%T); want %v (%T)", tc.kind, result, result, tc.expectedValue, tc.expectedValue)
			}
			if tc.expectedType != nil {
				if result == nil { // Should not be nil if expectedType is not nil
					t.Errorf("DefaultValueForPrimitiveTypeKind(%v) result is nil; want type %v", tc.kind, tc.expectedType)
				} else if reflect.TypeOf(result) != tc.expectedType {
					t.Errorf("DefaultValueForPrimitiveTypeKind(%v) type = %T; want %v", tc.kind, result, tc.expectedType)
				}
			} else { // Expecting nil result
				if result != nil {
					t.Errorf("DefaultValueForPrimitiveTypeKind(%v) result = %v (%T); want nil", tc.kind, result, result)
				}
			}
			// Note: This test doesn't check for the log warning on unsupported types.
		})
	}
}

// --- Test RandomValueForPrimitiveTypeKind ---

func TestRandomValueForPrimitiveTypeKind(t *testing.T) {
	testCases := []struct {
		name         string
		kind         reflect.Kind
		expectedType reflect.Type
	}{
		{"Int64", reflect.Int64, reflect.TypeOf(int64(0))},
		{"Float64", reflect.Float64, reflect.TypeOf(float64(0.0))},
		{"Bool", reflect.Bool, reflect.TypeOf(true)},
		{"String", reflect.String, reflect.TypeOf("")},
		{"UnsupportedChan", reflect.Chan, nil}, // Expect nil for unsupported
		{"UnsupportedPtr", reflect.Ptr, nil},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Run a few times for randomness checks
			for i := 0; i < 5; i++ {
				result := utils.RandomValueForPrimitiveTypeKind(tc.kind)

				if tc.expectedType != nil {
					if result == nil {
						t.Errorf("RandomValueForPrimitiveTypeKind(%v) iteration %d result is nil; want type %v", tc.kind, i, tc.expectedType)
						continue
					}
					resultType := reflect.TypeOf(result)
					if resultType != tc.expectedType {
						t.Errorf("RandomValueForPrimitiveTypeKind(%v) iteration %d type = %v; want %v", tc.kind, i, resultType, tc.expectedType)
					}
					// Specific checks for String length > 0
					if tc.kind == reflect.String {
						if s, ok := result.(string); ok {
							if len(s) == 0 {
								t.Errorf("RandomValueForPrimitiveTypeKind(reflect.String) iteration %d returned empty string", i)
							}
						} else {
							t.Errorf("RandomValueForPrimitiveTypeKind(reflect.String) iteration %d did not return a string", i)
						}
					}
				} else { // Expecting nil result for unsupported types
					if result != nil {
						t.Errorf("RandomValueForPrimitiveTypeKind(%v) iteration %d result = %v (%T); want nil", tc.kind, i, result, result)
					}
				}
			}
			// Note: This test doesn't check for the log warning on unsupported types.
		})
	}
}

// --- Test EdgeCaseValueForPrimitiveTypeKind ---

func TestEdgeCaseValueForPrimitiveTypeKind(t *testing.T) {
	// Define expected edge cases here for comparison (matches the source)
	intEdgeCase := []int64{0, 1, -1, math.MaxInt64, math.MinInt64, math.MaxInt32, math.MinInt32}
	floatEdgeCase := []float64{0.0, 1.0, -1.0, math.MaxFloat64, math.SmallestNonzeroFloat64, math.MaxFloat32, math.SmallestNonzeroFloat32}
	stringEdgeCase := []string{"", " ", "%20", ".*"}
	boolEdgeCase := []bool{true, false}

	testCases := []struct {
		name             string
		kind             reflect.Kind
		expectedType     reflect.Type
		expectedValueSet any // Slice of expected values
	}{
		{"Int64", reflect.Int64, reflect.TypeOf(int64(0)), intEdgeCase},
		{"Float64", reflect.Float64, reflect.TypeOf(float64(0.0)), floatEdgeCase},
		{"Bool", reflect.Bool, reflect.TypeOf(true), boolEdgeCase},
		{"String", reflect.String, reflect.TypeOf(""), stringEdgeCase},
		{"UnsupportedInterface", reflect.Interface, nil, nil}, // Expect nil for unsupported
		{"UnsupportedArray", reflect.Array, nil, nil},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Run multiple times since the selection is random
			for i := 0; i < 10; i++ {
				result := utils.EdgeCaseValueForPrimitiveTypeKind(tc.kind)

				if tc.expectedType != nil {
					if result == nil {
						t.Errorf("EdgeCaseValueForPrimitiveTypeKind(%v) iteration %d result is nil; want type %v", tc.kind, i, tc.expectedType)
						continue
					}
					resultType := reflect.TypeOf(result)
					if resultType != tc.expectedType {
						t.Errorf("EdgeCaseValueForPrimitiveTypeKind(%v) iteration %d type = %v; want %v", tc.kind, i, resultType, tc.expectedType)
						continue
					}

					// Check if the result is one of the expected edge values
					found := false
					switch v := result.(type) {
					case int64:
						if set, ok := tc.expectedValueSet.([]int64); ok {
							found = slices.Contains(set, v)
						}
					case float64:
						if set, ok := tc.expectedValueSet.([]float64); ok {
							found = slices.Contains(set, v)
						}
					case bool:
						if set, ok := tc.expectedValueSet.([]bool); ok {
							found = slices.Contains(set, v)
						}
					case string:
						if set, ok := tc.expectedValueSet.([]string); ok {
							found = slices.Contains(set, v)
						}
					}

					if !found {
						t.Errorf("EdgeCaseValueForPrimitiveTypeKind(%v) iteration %d result %v not found in expected set %v", tc.kind, i, result, tc.expectedValueSet)
					}

				} else { // Expecting nil result for unsupported types
					if result != nil {
						t.Errorf("EdgeCaseValueForPrimitiveTypeKind(%v) iteration %d result = %v (%T); want nil", tc.kind, i, result, result)
					}
				}
			}
			// Note: This test doesn't check for the log warning on unsupported types.
		})
	}
}

// --- Test FormatServiceName ---

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This test depends on the unexported function ConvertToStandardCase. !!!
// !!! Adjust the test based on its actual behavior.                       !!!
// !!! Assuming ConvertToStandardCase converts to lowercase for this test.   !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Mock or define ConvertToStandardCase if needed for testing in isolation,
// or ensure it's available in the package.
// For this example, we'll just assume it converts to lowercase.
func ConvertToStandardCase(s string) string {
	// Replace with actual implementation or mock if needed
	var result bytes.Buffer
	for _, r := range s {
		if r >= 'A' && r <= 'Z' {
			result.WriteRune(r + ('a' - 'A'))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

func TestFormatServiceName(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{"RemoveSuffix", "MyAwesomeService", "myawesome"},
		{"RemoveSuffixCaseInsensitive", "ProductSERVICE", "product"}, // Assuming lowercase conversion
		{"NoSuffix", "UserCatalog", "usercatalog"},
		{"OnlySuffix", "Service", ""}, // Assuming lowercase conversion results in "service" -> ""
		{"ShortName", "API", "api"},
		{"EmptyInput", "", ""},
		{"SuffixNotAtEnd", "ServiceDesk", "servicedesk"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := utils.FormatServiceName(tc.input)
			if result != tc.expected {
				t.Errorf("FormatServiceName(%q) = %q; want %q", tc.input, result, tc.expected)
			}
		})
	}
}

// --- Test Base64ToHex ---

func TestBase64ToHex(t *testing.T) {
	testCases := []struct {
		name          string
		inputBase64   string
		expectedHex   string
		expectError   bool
		expectedError error // Optional: Specific error type/message check
	}{
		{"ValidHelloWorld", "SGVsbG8gd29ybGQ=", "48656c6c6f20776f726c64", false, nil},
		{"ValidFoobar", "Zm9vYmFy", "666f6f626172", false, nil},
		{"ValidSingleChar", "YQ==", "61", false, nil}, // 'a'
		{"EmptyString", "", "", false, nil},
		{"InvalidChars", "Invalid Base64!!!", "", true, base64.CorruptInputError(0)}, // Expecting corrupt input error
		{"InvalidPadding", "YQ=", "", true, base64.CorruptInputError(0)},             // Incorrect padding
		{"URLSafeEncoding", "_-A=", "", true, base64.CorruptInputError(0)},           // Using URL safe chars without URL decoder
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			hexStr, err := utils.Base64ToHex(tc.inputBase64)

			if tc.expectError {
				if err == nil {
					t.Errorf("Base64ToHex(%q) expected an error, but got nil", tc.inputBase64)
				} else {
					// Optional: Check for specific error type if needed
					if tc.expectedError != nil {
						// Note: Direct error comparison might fail. Check type or message.
						// Example: Check if it's a base64.CorruptInputError
						if _, ok := err.(base64.CorruptInputError); !ok {
							t.Logf("Base64ToHex(%q) got error type %T, potentially expected %T or similar", tc.inputBase64, err, tc.expectedError)
						}
					}
					// Check that output is empty on error, as per implementation
					if hexStr != "" {
						t.Errorf("Base64ToHex(%q) returned non-empty string %q on error", tc.inputBase64, hexStr)
					}
				}
				// Note: This test doesn't check for the log message on error.
			} else {
				if err != nil {
					t.Errorf("Base64ToHex(%q) expected no error, but got: %v", tc.inputBase64, err)
				}
				if hexStr != tc.expectedHex {
					t.Errorf("Base64ToHex(%q) = %q; want %q", tc.inputBase64, hexStr, tc.expectedHex)
				}
			}
		})
	}
}
