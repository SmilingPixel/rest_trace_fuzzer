import json
import sys
from typing import List, Dict, Any

# [proposal: build: define standard way to recognize machine-generated files · Issue #13560 · golang/go](https://github.com/golang/go/issues/13560)
DO_NOT_EDIT_HEADER = '// Code generated by arg_config_generate.py. DO NOT EDIT.'
BLANK_LINE = ''

def load_config(config_path: str) -> List[Dict[str, Any]]:
    """
    Load the configuration from a JSON file.

    Args:
        config_path (str): Path to the JSON configuration file.

    Returns:
        List[Dict[str, Any]]: The loaded configuration.
    """
    with open(config_path) as f:
        return json.load(f)

def to_camel_case(snake_str: str, upper_first: bool = False) -> str:
    """
    Convert a snake_case string to CamelCase or camelCase.

    Args:
        snake_str (str): The snake_case string.
        upper_first (bool): Whether to make the first letter uppercase.

    Returns:
        str: The CamelCase or camelCase string.
    """
    components = snake_str.split('_')
    for i in range(len(components)):
        if components[i].lower() in ('url', 'id', 'http', 'https'):
            components[i] = components[i].upper()
        elif components[i].lower() == 'openapi':
            components[i] = 'OpenAPI'
        else:
            components[i] = components[i].title()
    if not upper_first:
        components[0] = components[0][0].lower() + components[0][1:]
        if components[0].lower() in ('url', 'id', 'http', 'https'):
            components[0] = components[0].upper()
        elif components[0].lower() == 'openapi':
            components[0] = 'OpenAPI'
    return ''.join(components)

def to_upper_snake_case(snake_str: str) -> str:
    """
    Convert a snake_case string to UPPER_SNAKE_CASE.

    Args:
        snake_str (str): The snake_case string.

    Returns:
        str: The UPPER_SNAKE_CASE string.
    """
    return snake_str.upper()

def to_go_type(json_type: str) -> str:
    """
    Convert a JSON type to a Go type.

    Args:
        json_type (str): The JSON type.

    Returns:
        str: The Go type.
    """
    if json_type == "string":
        return "string"
    elif json_type == "number":
        return "int"
    elif json_type == "duration":
        return "time.Duration"
    elif json_type == "boolean":
        return "bool"
    else:
        return "string"

def generate_godoc(description: str) -> str:
    """
    Generate GoDoc comment for a field.

    Args:
        description (str): The description of the field.

    Returns:
        str: The GoDoc comment.
    """
    return f"// {description}"

def generate_arg_parse_code(config: List[Dict[str, Any]]) -> str:
    """
    Generate the Go code for parsing command-line arguments.

    Args:
        config (List[Dict[str, Any]]): The configuration.

    Returns:
        str: The generated Go code.
    """
    package_declaration = "package config"
    imported_packages = ["flag", "os", "strconv", "github.com/bytedance/sonic", "github.com/joho/godotenv", "github.com/rs/zerolog/log"]
    arg_parse_code_lines = []
    arg_parse_code_lines.append(DO_NOT_EDIT_HEADER)
    arg_parse_code_lines.append(package_declaration)
    for package in imported_packages:
        arg_parse_code_lines.append(f'import "{package}"')
    
    # parse method code
    arg_parse_code_lines.append("func ParseCmdArgs() {")
    for arg in config:
        arg_name = arg["arg_name"]
        config_name = arg["config_name"]
        description = arg["description"]
        default_value = arg["default"]
        go_type = to_go_type(arg["type"])

        if go_type == "time.Duration":
            arg_parse_code_lines.append(f'flag.DurationVar(&GlobalConfig.{to_camel_case(config_name, True)}, "{arg_name}", {default_value}, "{description}")')
        elif go_type == "int":
            arg_parse_code_lines.append(f'flag.IntVar(&GlobalConfig.{to_camel_case(config_name, True)}, "{arg_name}", {default_value}, "{description}")')
        elif go_type == "bool":
            arg_parse_code_lines.append(f'flag.BoolVar(&GlobalConfig.{to_camel_case(config_name, True)}, "{arg_name}", {"true" if default_value else "false"}, "{description}")')
        else:
            arg_parse_code_lines.append(f'flag.StringVar(&GlobalConfig.{to_camel_case(config_name, True)}, "{arg_name}", "{default_value}", "{description}")')

    arg_parse_code_lines.append("flag.Parse()")
    arg_parse_code_lines.append(BLANK_LINE)

    # If config file is provided, load the config from the file
    arg_parse_code_lines.append("// If config file is provided, load the config from the file")
    arg_parse_code_lines.append("if GlobalConfig.ConfigFilePath != \"\" {")
    arg_parse_code_lines.append("configData, err := os.ReadFile(GlobalConfig.ConfigFilePath)")
    arg_parse_code_lines.append("if err != nil {")
    arg_parse_code_lines.append('log.Err(err).Msgf("[ParseCmdArgs] Failed to read config file: %s", err)')
    arg_parse_code_lines.append("}")
    arg_parse_code_lines.append("err = sonic.Unmarshal(configData, GlobalConfig)")
    arg_parse_code_lines.append("if err != nil {")
    arg_parse_code_lines.append('log.Err(err).Msgf("[ParseCmdArgs] Failed to parse config file: %s", err)')
    arg_parse_code_lines.append("}")
    arg_parse_code_lines.append("}")
    arg_parse_code_lines.append(BLANK_LINE)

    # If environment variables are provided, override the config
    arg_parse_code_lines.append("// If environment variables are provided, override the config")
    arg_parse_code_lines.append("err := godotenv.Load()")
    arg_parse_code_lines.append("if err != nil {")
    arg_parse_code_lines.append('log.Err(err).Msgf("[ParseCmdArgs] Failed to load environment variables: %s", err)')
    arg_parse_code_lines.append("}")
    for arg in config:
        config_name = arg["config_name"]
        go_type = to_go_type(arg["type"])
        arg_parse_code_lines.append(f'if envVal, ok := os.LookupEnv("{to_upper_snake_case(config_name)}"); ok && envVal != "" {{')
        if go_type == "time.Duration":
            arg_parse_code_lines.append(f'envValDuration, err := time.ParseDuration(envVal)')
            arg_parse_code_lines.append("if err != nil {")
            arg_parse_code_lines.append('log.Err(err).Msgf("[ParseCmdArgs] Failed to parse duration: %s", err)')
            arg_parse_code_lines.append("}")
            arg_parse_code_lines.append(f'GlobalConfig.{to_camel_case(config_name, True)} = envValDuration')
        elif go_type == "int":
            arg_parse_code_lines.append(f'envValInt, err := strconv.Atoi(envVal)')
            arg_parse_code_lines.append("if err != nil {")
            arg_parse_code_lines.append('log.Err(err).Msgf("[ParseCmdArgs] Failed to parse int: %s", err)')
            arg_parse_code_lines.append("}")
            arg_parse_code_lines.append(f'GlobalConfig.{to_camel_case(config_name, True)} = envValInt')
        elif go_type == "bool":
            arg_parse_code_lines.append(f'GlobalConfig.{to_camel_case(config_name, True)} = true')
        else:  
            arg_parse_code_lines.append(f'GlobalConfig.{to_camel_case(config_name, True)} = envVal')
        arg_parse_code_lines.append("}")
    arg_parse_code_lines.append(BLANK_LINE)


    arg_parse_code_lines.append('jsonStr, _ := sonic.Marshal(GlobalConfig)')
    arg_parse_code_lines.append('log.Info().Msgf("[ParseCmdArgs] Parsed arguments: %s", jsonStr)')
    arg_parse_code_lines.append("}")

    return "\n".join(arg_parse_code_lines)

def generate_config_code(config: List[Dict[str, Any]]) -> str:
    """
    Generate the Go code for the configuration struct.

    Args:
        config (List[Dict[str, Any]]): The configuration.

    Returns:
        str: The generated Go code.
    """
    package_declaration = "package config"
    imported_packages = []
    config_code_lines = []
    config_code_lines.append(DO_NOT_EDIT_HEADER)
    config_code_lines.append(package_declaration)
    for package in imported_packages:
        config_code_lines.append(f'import "{package}"')

    config_code_lines.append("var GlobalConfig *RuntimeConfig")
    config_code_lines.append("type RuntimeConfig struct {")
    for arg in config:
        config_name = arg["config_name"]
        description = arg["description"]
        go_type = to_go_type(arg["type"])

        config_code_lines.append(f'{generate_godoc(description)}')
        config_code_lines.append(f'{to_camel_case(config_name, True)} {go_type} `json:"{to_camel_case(config_name, False)}"`')
        config_code_lines.append(BLANK_LINE)
    config_code_lines.append("}")

    config_code_lines.append("func InitConfig() {")
    config_code_lines.append("GlobalConfig = &RuntimeConfig{}")
    config_code_lines.append("}")

    return "\n".join(config_code_lines)

def write_to_file(filepath: str, content: str) -> None:
    """
    Write content to a file.

    Args:
        filepath (str): The path to the file.
        content (str): The content to write.
    """
    with open(filepath, 'w') as f:
        f.write(content)

def main(config_path: str) -> None:
    """
    Main function to generate the Go code for argument parsing and configuration.

    Args:
        config_path (str): The path to the configuration directory.
    """
    config_file_path = config_path + '/arg_config.json'
    arg_parse_go_code_path = config_path + '/arg_parse.go'
    config_go_code_path = config_path + '/config.go'
    config = load_config(config_file_path)
    arg_parse_code = generate_arg_parse_code(config)
    config_code = generate_config_code(config)

    write_to_file(arg_parse_go_code_path, arg_parse_code)
    write_to_file(config_go_code_path, config_code)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python arg_config_generate.py path_to_config_dir")
        sys.exit(1)
    main(sys.argv[1])