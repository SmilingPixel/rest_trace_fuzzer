package static

import (
	"maps"
	"resttracefuzzer/internal/config"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/rs/zerolog/log"
)

// APIManager represents an API manager that manages the API definition,
// dependency graph, dataflow graph and other static information of the API.
type APIManager struct {
	// The OpenAPI definition of the API.
	APIDoc *openapi3.T

	// The map from the simple API method to the OpenAPI operation.
	APIMap map[SimpleAPIMethod]*openapi3.Operation

	// Internal APIs of the services in the system.
	InternalServiceAPIDoc *openapi3.T

	// The map from the service name to the map from the method to the OpenAPI operation.
	// It include all internal APIs as well as those of frontend.
	ServiceAPIMap map[string]map[SimpleAPIMethod]*openapi3.Operation

	// The dependency graph of the API.
	// It only include the external APIs, but internal service APIs may be used to enhance the graph (you can set it by config `use-internal-service-api-dependency`).
	APIDependencyGraph *APIDependencyGraph

	// The Dataflow graph of the internal APIs.
	APIDataflowGraph *APIDataflowGraph

	// Reachability information of external APIs and internal service interfaces.
	// This map is initialized from API doc, and would not be updated in the process of fuzzing.
	// We will keep updating the dynamic (runtime) version in runtime package
	StaticReachabilityMap *ReachabilityMap
}

// NewAPIManager creates a new APIManager.
func NewAPIManager() *APIManager {
	return &APIManager{}
}

// InitFromDocs initializes the API manager from docs, including that of external APIs and of internal service interfaces.
// It do some initilization work that needs both docs as well, such as reachability map.
func (m *APIManager) InitFromDocs(externalDoc, internalDoc *openapi3.T) {
	m.initFromSystemDoc(externalDoc)
	m.initFromServiceDoc(internalDoc)

	// add frontend APIs' info to ServiceAPIMap
	// We hardcode `frontend` as the frontend 'service'
	// TODO: make frontend 'service' name configurable @xunzhou24
	frontendServiceName := "frontend"
	frontendServiceAPIMap := make(map[SimpleAPIMethod]*openapi3.Operation)
	maps.Copy(frontendServiceAPIMap, m.APIMap)
	m.ServiceAPIMap[frontendServiceName] = frontendServiceAPIMap

	// Generate the dataflow graph of the service APIs.
	m.APIDataflowGraph = NewAPIDataflowGraph()
	m.APIDataflowGraph.ParseFromServiceDocument(m.ServiceAPIMap)

	// Compute reachability map from the API doc.
	// we only check reachability from external APIs to internal APIs
	nodes := m.APIDataflowGraph.GetAllNodes()
	externalEndpointNodeSet := make(map[InternalServiceEndpoint]struct{})
	for _, node := range nodes {
		if node.ServiceName == frontendServiceName {
			externalEndpointNodeSet[node] = struct{}{}
		}
	}
	m.StaticReachabilityMap = NewReachabilityMap()
	for node := range externalEndpointNodeSet {
		distanceFromNode := m.APIDataflowGraph.GetDistanceBySource(node) // get a distance map of all nodes that are reachable from the node
		for targetNode := range distanceFromNode {
			if targetNode.ServiceName != frontendServiceName {
				log.Debug().Msgf("[APIManager.InitFromDocs] Adding reachability from %s to %s", node.ID(), targetNode.ID())
				m.StaticReachabilityMap.AddReachability(node.SimpleAPIMethod, targetNode)
			}
		}
	}
}

// InitFromDoc initializes the API manager from an OpenAPI document.
// The document is of interfaces of the whole system.
func (m *APIManager) initFromSystemDoc(doc *openapi3.T) {
	m.APIDoc = doc
	m.APIMap = make(map[SimpleAPIMethod]*openapi3.Operation)
	for path, pathItem := range doc.Paths.Map() {
		for method, operation := range pathItem.Operations() {
			// By default, the type of the API is HTTP.
			simpleAPIMethod := SimpleAPIMethod{
				Method:   method,
				Endpoint: path,
				Typ:      SimpleAPIMethodTypeHTTP,
			}
			m.APIMap[simpleAPIMethod] = operation
		}
	}
}

// initFromServiceDocs initializes the API manager from the OpenAPI document of the internal services.
func (m *APIManager) initFromServiceDoc(doc *openapi3.T) {
	m.InternalServiceAPIDoc = doc
	m.ServiceAPIMap = make(map[string]map[SimpleAPIMethod]*openapi3.Operation)
	for _, pathItem := range doc.Paths.Map() {
		for _, operation := range pathItem.Operations() {
			// In OpenAPI generated by protoc-gen-openapi, operationID is in the format of `{Service}_{Method}`.
			// We can use this format to extract the service name and method name.
			operationID := operation.OperationID
			// Split the operationID by `_`.
			operationIDParts := strings.Split(operationID, "_")
			if len(operationIDParts) != 2 {
				log.Warn().Msgf("[APIManager.initFromServiceDoc] Invalid operationID: %s", operationID)
				continue
			}
			serviceName := operationIDParts[0]
			methodName := operationIDParts[1]
			// TODO: we treat all internal interfaces as gRPC methods for now. @xunzhou24
			simpleMethod := SimpleAPIMethod{
				Endpoint: methodName,
				Method:   methodName,
				Typ:      SimpleAPIMethodTypeGRPC,
			}
			if _, exists := m.ServiceAPIMap[serviceName]; !exists {
				m.ServiceAPIMap[serviceName] = make(map[SimpleAPIMethod]*openapi3.Operation)
			}
			m.ServiceAPIMap[serviceName][simpleMethod] = operation
		}
	}
}

// InitDependencyGraph initializes the dependency graph of the API manager.
// It accepts the graph of the external API dependency and the internal API dependency.
// If config `use-internal-service-api-dependency` is set to true, the internal API dependency will be used to enhance the final graph.
// Otherwise, `internalAPIDependencyGraph` will be ignored (you can pass any value in such case), and the final API dependency graph will be the same as `externalAPIDependencyGraph`.
func (m *APIManager) InitDependencyGraph(externalAPIDependencyGraph, internalAPIDependencyGraph *APIDependencyGraph) {
	m.APIDependencyGraph = externalAPIDependencyGraph
	if config.GlobalConfig.UseInternalServiceAPIDependency {
		if internalAPIDependencyGraph == nil {
			log.Warn().Msg("[APIManager.InitDependencyGraph] internalAPIDependencyGraph is nil, use externalAPIDependencyGraph only")
			return
		}
		// TODO: implement this function @xunzhou24
	}
}

// GetOperationByMethod returns the OpenAPI operation of the given API method.
func (m *APIManager) GetOperationByMethod(method SimpleAPIMethod) (*openapi3.Operation, bool) {
	if operation, ok := m.APIMap[method]; ok {
		return operation, true
	}
	return nil, false
}

// GetRandomAPIMethod returns a random API method from the API manager.
func (m *APIManager) GetRandomAPIMethod() SimpleAPIMethod {
	// Golang map iteration order is random.
	// See [official doc](https://go.dev/blog/maps#iteration-order).
	for method := range m.APIMap {
		return method
	}
	log.Warn().Msg("[APIManager.GetRandomAPIMethod] APIMap is empty, return empty method")
	return SimpleAPIMethod{}
}

// GetConsumerAPIMethodsByProducers returns the consumer API methods of the given producer API methods.
// You should set the `APIDependencyGraph` field of the API manager before calling this function.
func (m *APIManager) GetConsumerAPIMethodsByProducers(producers []SimpleAPIMethod) []SimpleAPIMethod {
	var res []SimpleAPIMethod
	for _, producer := range producers {
		if consumers, ok := m.APIDependencyGraph.Graph[producer]; ok {
			res = append(res, consumers...)
		}
	}
	return res
}
