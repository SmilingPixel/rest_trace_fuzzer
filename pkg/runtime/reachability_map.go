package runtime

import (
	"fmt"
	"resttracefuzzer/pkg/feedback/trace"
	"resttracefuzzer/pkg/static"
	"resttracefuzzer/pkg/utils"

	"github.com/rs/zerolog/log"
)

// RuntimeReachabilityMap is a map that tracks the reachability of functions at runtime.
// The map would be updated during execution to reflect the current knowledge of the system components.
// The map contains two ReachabilityMap, both of type [resttracefuzzer/pkg/static.ReachabilityMap]. One is of hign confidence level and the other is of low confidence level.
// Note: to handle various formats of service names, they would be processed when updating the map.
type RuntimeReachabilityMap struct {
	// High confidence reachability map
	HighConfidenceMap *static.ReachabilityMap
	// Low confidence reachability map
	LowConfidenceMap *static.ReachabilityMap
}

// NewRuntimeReachabilityMap creates a new RuntimeReachabilityMap with empty maps.
func NewRuntimeReachabilityMap() *RuntimeReachabilityMap {
	highConfidenceMap := static.NewReachabilityMap()
	lowConfidenceMap := static.NewReachabilityMap()
	return &RuntimeReachabilityMap{
		HighConfidenceMap: highConfidenceMap,
		LowConfidenceMap:  lowConfidenceMap,
	}
}

// NewRuntimeReachabilityMapFromStaticMap creates a new RuntimeReachabilityMap from static maps.
// The static maps is generated from API Doc, and is of low confidence level.
// service names in the static maps may not be formatted, so we need to format them when adding to the map.
func NewRuntimeReachabilityMapFromStaticMap(staticMap *static.ReachabilityMap) *RuntimeReachabilityMap {
	hignConfidenceMap := static.NewReachabilityMap()
	lowConfidenceMap := static.NewReachabilityMap()

	// Copy the static map to the low confidence map
	for external, internals := range staticMap.External2Internal {
		for _, internal := range internals {
			internal.ServiceName = utils.FormatServiceName(internal.ServiceName)
			lowConfidenceMap.AddReachability(external, internal)
		}
	}
	for internal, externals := range staticMap.Internal2External {
		internal.ServiceName = utils.FormatServiceName(internal.ServiceName)
		for _, external := range externals {
			lowConfidenceMap.AddReachability(external, internal)
		}
	}

	return &RuntimeReachabilityMap{
		HighConfidenceMap: hignConfidenceMap,
		LowConfidenceMap:  lowConfidenceMap,
	}
}

// AddReachabilityWithConfidenceLevel adds reachability information with confidence level to the map.
// We only support two confidence levels: high (1) and low (0) at the moment.
func (r *RuntimeReachabilityMap) AddReachabilityWithConfidenceLevel(external static.SimpleAPIMethod, internal static.InternalServiceEndpoint, confidenceLevel int) {
	// format service name
	internal.ServiceName = utils.FormatServiceName(internal.ServiceName)
	if confidenceLevel > 0 {
		r.HighConfidenceMap.AddReachability(external, internal)
	} else {
		r.LowConfidenceMap.AddReachability(external, internal)
	}
}

// UpdateFromCallInfos updates the reachability map from the call info.
// The call info is parsed from traces generated by services in the system.
// Trace reflects the real info of the system, so we should update the high confidence map.
func (r *RuntimeReachabilityMap) UpdateFromCallInfos(externalEndpoint static.SimpleAPIMethod, callInfoList []*trace.CallInfo) error {
	if len(callInfoList) == 0 {
		return nil
	}
	
	// parse internal service endpoints from call info
	internalServiceEndpoints := make([]static.InternalServiceEndpoint, 0)
	for _, callInfo := range callInfoList {
		// parse the internal service endpoint from the call info
		internalServiceEndpoint := static.InternalServiceEndpoint{
			ServiceName:     callInfo.TargetService,
			SimpleAPIMethod: static.SimpleAPIMethod{
				Endpoint: callInfo.Method,
				Method: callInfo.Method,
				Typ: static.SimpleAPIMethodTypeGRPC, // TODO: support more types instead of hard coding @xunzhou24
			},
		}
		internalServiceEndpoints = append(internalServiceEndpoints, internalServiceEndpoint)
	}

	// Update the high confidence map
	for _, internalServiceEndpoint := range internalServiceEndpoints {
		r.HighConfidenceMap.AddReachability(externalEndpoint, internalServiceEndpoint)
	}
	
	// If the info exists in the low confidence map, we should remove it from the low confidence map.
	for _, internalServiceEndpoint := range internalServiceEndpoints {
		r.LowConfidenceMap.RemoveReachability(externalEndpoint, internalServiceEndpoint)
	}

	log.Debug().Msgf("[RuntimeReachabilityMap.UpdateFromCallInfo] Updated high confidence map with external: %s, internal: %v", externalEndpoint, internalServiceEndpoints)

	return nil
}

// GetReachableInternalEndpointsByExternalAPI gets the reachable internal endpoints by external API.
// The reachable internal endpoints are the ones that can be reached from the external API.
// Parameter `useHighConfidenceOnly` indicates whether to use high confidence map only or not.
// If true, we only use high confidence map. If false, we use both high and low confidence maps (but the high one has higher priority).
func (r *RuntimeReachabilityMap) GetReachableInternalEndpointsByExternalAPI(externalAPI static.SimpleAPIMethod, useHighConfidenceOnly bool) ([]static.InternalServiceEndpoint, error) {
	// Check if the external API is in the high confidence map
	var internalEndpoints []static.InternalServiceEndpoint
	externalAPINotExistErr := fmt.Errorf("external API %s not exist in the reachability map", externalAPI)
	internalEndpoints, exist := r.HighConfidenceMap.GetInternalsByExternal(externalAPI)
	if !exist {
		return nil, externalAPINotExistErr
	}
	
	// If not found in high confidence map, check the low confidence map
	if len(internalEndpoints) == 0 && !useHighConfidenceOnly {
		internalEndpoints, exist = r.LowConfidenceMap.GetInternalsByExternal(externalAPI)
		if !exist {
			return nil, externalAPINotExistErr
		}
	}
	return internalEndpoints, nil
}
